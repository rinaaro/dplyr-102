---
title: "Financial data analysis"
author: "Arina Agaronyan"
format: 
  html: 
    echo: false 
---

goal to analyse loans
description of data enables 

```{r config}
#| message: false
here::i_am("dplyr-102.Rproj")
library(here)
library(vroom) ## or readr
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)
theme_set(theme_bw())
```

## Data loading

```{r load_data}
#| message: false
clients <- vroom(here("data", "client.csv")) ## split file name into directories, then file name
accounts <- vroom(here("data", "account.csv"))
disp <- vroom(here("data", "disp.csv"))
```


## Joining data tables
A collection of joining functions of the form '*_join'.

### Inner join

```{r da}
da <- inner_join(accounts, disp) ## merges data using the one same variable (account_id here)
```

```{r cda}
cda <- inner_join(clients, da, by = join_by(client_id), suffix = c("_home", "_bank")) 
#join - look for common vars and join on those vars, but here leads to removal of some values (~10%) which have mismatching values for a var (due to moving...- don't live where the bank is) so have to add specification of joinby
#by = join by makes two vers of other common var - district_id.x/y - can rename
```


### Home district vs Bank district

```{r home_diff}
home_diff_bank <- cda |>
  filter(district_id_home != district_id_bank) |> ## != not equal to
  nrow()
```
We observe that `r home_diff_bank` clients have a bank in another district than the one they live in.

(May be overestimation due to families, so check clients who share account but don't live together)
```{r filter_home_diff}
cda |> 
  group_by(account_id) |>
  distinct(district_id_home) |>
  summarise(N=n()) |>
  filter(N>1)
```
(nevermind)


### Gender gap?

```{r countG}
clients |> count(gender)
```

```{r}
clients |>
  ggplot(aes(y=gender)) +
  geom_bar() ## if long vaues on geom_bar, better on y axis. can originally put x= then + coord_flip()
```

Acount distribution
```{r}
cda |>
  count(gender, type) |>
  group_by(gender)|>
  mutate(freq=n/sum(n))|>
  select(-n) |> 
  ungroup() |>
  pivot_wider(values_from = freq, names_from = type)
```

```{r}
cda |>
  ggplot(aes(y=gender, fill=type)) +
  geom_bar(position = "fill")
```

```{r}
chisq.test(cda |> pull(gender), 
           cda |> pull(type))
```
p-value=0.5, can't reject null hypothesis of independence

observational - not causality


## Loan analysis

```{r}
#| message: false
loan <- vroom(here("data", "loan.csv")) 
#dbl values - numerical - load ad account id not good as numerical - want as integers
#chr - status identified as text, not good - want as factor, if error in data, better not to use as.factor

loan <- loan |> #mutating is ordered, first mutates first column, then second...
  mutate(status = factor(status, levels=c("A", "B", "C", "D")), 
         loan_id=as.integer(loan_id),
         account_id=as.integer(account_id)) #not compulsory
```

Factor recoding of `status` introduced `r loan |> filter(is.na(status)) |> nrow()` error(s).



```{r}
loan_counts <- 
  ggplot(loan, aes(x=status, fill=status)) + #status discrete var
  geom_bar()
loan_counts
```

Want to compute loss ratio - amount lost by bank in loans

Compute aggregate based on loan status
```{r}
loan |>
  group_by(status) |>
  summarise(sum(amount))
```

number of failed loans small graphically, but actual money sum is quite large
- can't represent this in ggplot directly

distribution of amounts conditioned on status - facet...


```{r}
ggplot(loan, aes(x=status, y=amount))+
  geom_boxplot()
```
even median of B larger than A - makes sense - loan credit, probability of default could extend loan
(don't know potential confounding factors)
defaults are associated with big loans - increased risk of non-reimbursement

```{r}
loan_amounts <- 
loan |>
  group_by(status) |>
  summarise("total amount"=sum(amount)) |>
ggplot(aes(x=status, y=`total amount`, fill=status)) +
  geom_col()
loan_amounts
```
want two graphical representations side by side - need new library(patchwork)

```{r}
loan_counts + loan_amounts
```

```{r}
(loan_counts + coord_flip()) / (loan_amounts + coord_flip())
```

With geom_bar, can ask for statistical layer to do analysis - but complicated. As combination of geom_col and stat_count? just use prev eg






Want a better view of AB on one side and CD on other - use geom_bar to simplify

```{r}
(loan |>
  filter(status %in% c("A", "B")) |>
  ggplot(aes(x=status)) +
  geom_bar()) +
(loan |>
  filter(status %in% c("C", "D")) |>
  ggplot(aes(x=status)) +
  geom_bar())
```
current vs past loans =- new column to say whether loan is active or finished
```{r}
loan <- loan |>
  mutate(active = if_else(status %in% c("A", "B"), "Past", "Active"))
```

```{r}
ggplot(loan, aes(x=status, fill=status)) +
  geom_bar() +
  facet_wrap(~active, scales="free") # can do free_x if want only x axis to be free
```

```{r}
ggplot(loan, aes(y=active, fill = status))+
  geom_bar(position = "fill")
```

```{r}
loan <- 
  loan|>
  mutate(default= status %in% c("B", "D"))
```

```{r}
ggplot(loan, aes(y=active, fill = default))+
  geom_bar(position = "fill")
```

want each var to describe a single feature - untangling - easier to leverage into graphical representations, teste, etc...




